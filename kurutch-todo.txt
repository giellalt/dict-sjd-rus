Kurutch sjd-rus

Todo:

automatically:
1. merge of original reference entries (i.e. having kur_ID) with content entries (i.e. without ID) 
   trigger: string (watch out for ambiguities)


Merging related entries by the LINK-element of type SM and OT:

to be solved according to the following two rules
RULE1 (LINK TYPE="SM")
-find two entries of the following type
1st entry:   
   <E kur_ID="3">
		<L>аббрай</L>
		<T>
			<LINK TYPE="SM">аббьр</LINK>
		</T>
	</E>
2nd entry:
	<E>
		<L>аббрай</L>
		<POS>PRED</POS>
		<T>дождливый, дождлив</T>
		<X>ке̄ссь ля̄йй аббрай</X>
		<XT>лето было дождливым</XT>
	</E>
-these entry pairs always:
++have two similar contents in <L>
++1st entry has a kur_ID, 2nd entry doesn't
++1st entry has a mixed T-element with text and LINK children, 2nd entry doesn't
-merge these two entries into one entry, as in the following example
   <E kur_ID="3">
		<L>аббрай</L>
		<POS>PRED</POS>
		<DER type="SM">аббьр</DER>
		<T>дождливый, дождлив</T>
		<X>ке̄ссь ля̄йй аббрай</X>
		<XT>лето было дождливым</XT>
	</E>

RULE2 (LINK TYPE="OT"), I don't know yet how to deal with these entries, look at the following example
1st entry
	<E kur_ID="58">
		<L>АДЖЬ</L>
		<STEM>ажь</STEM>
		<CLASS>I,1</CLASS>
		<POS/>
		<T>отец</T>
#
<X>ажьнӣййт</X>
		<XT>оленёнок (самка) или важенка, подаренная отцом (напр. дочери на свадьбу)</XT>
	</E>

2nd entry	
	<E kur_ID="69">
		<L>ажь</L>
		<T>
			<LINK TYPE="OT">аджь</LINK>
		</T>
	</E>

probably, we don't need a pointer here because these 2nd entries simply show inflected forms of the 1st entries
I even believe that this inflected form is always similar to the element <STEM> in the 1st entries
if so couldn't we skip the whole merging and just delete the 2nd entries?
otherwise merging should result in something like the following

merged entry 
	<E kur_ID="58">
		<L>АДЖЬ</L>
		<STEM>ажь</STEM>
		<STEM type="OT" kur_ID="69">ажь</STEM>
		<CLASS>I,1</CLASS>
		<POS/>
		<T>…
		etc.		

===========================================
2. gt_dict structure: mapping like in the following example:
   
<e kur_ID="xxx">
	<lg>
		<l pos="xxx">xxx</l>
		<STEM>xxx</STEM> (1-100: z. 55)
		<CLASS>xxx</CLASS> (1-100: z. 56)
	</lg>
	<mg>
     	<semantics>
			<sem class="xxx"/>
		</semantics>

     <tg>
  ==> done
		 (1-100: z. 72, komma mapped on different t-elements)   ==> done
		 
         (1-100: z. 1348, semicollon mapped on different tg-elements)   ==> done
		 
		 (z. 136: different meaning groups: relevant order???)
		 
		 (z. 136: after dash/bracket/etc. = re) <== this is a
		 re-element related really to the tg (or perhaps even
		 t-element)   ==> TODO

TAM-element = grammar info (aspect, etc.); scopus is mg-element
(according to our discussion from 08.03.2011)!!!   ==> done

(z. 324: scopus mg-element, according to our discussion from 08.03.2011) 
<RE>PRJAM,PEREN</RE>   ==> done

			<t pos="xxx" xml:lang="xxx">xxx</t>
			<xg>
				<x type="xxx">xxx</x>
				<xt xml:lang="xxx">xxx</xt>
			</xg>

examples of <x> with several translations:
(101-500: z. 3258)
		<X>ва̄лльтэ ва̄лт</X>
		<XT xtnumber="1">завоевать свободу</XT>
		<XT xtnumber="2">стать своевольным</XT>
			
            <xg type=idiom subtype=blabla>
				<x>xxx</x>
				<xt xml:lang="xxx">xxx</xt>
			</xg>
  ==> done

example for idiom subtype (idiom groups are preliminary marked by # preceeding the whole group; idioms are always at the end of an <e> or <mg> (no other <x> following them):			

<X>парна бальяк, шӯрран — лӯјкак</X>
		<XT>POSLOVICA [ребёнка] маленького балуешь - с большим плачешь</XT>

		</tg>
	</mg>
</e>

  ==> done

101-500: z. 3536
		<T>выделывать/ выделать (шкуру крюком<LOOKUP xml:lang="sjd">крӯһкь</LOOKUP>
		</T>

  ==> TODO


3. non-capitals in the element <L>

  ==> done

4. rules for automatic PoS tagging (most of them are already included in the script)

- if there is something like
type="PONUD_K" or type="STRAD_K" or <RE>BESL</RE>
in the entry then assigne pos="verb"

- if there is an element <TAM> in the entry then assigne pos="verb"
   ==> done

5. the tags x_GENDER (z.B. F_GENDER, etc.) x_NUMBER (z.B. PL_NUMBER, etc.) should be transfered into an attribute of <t>; PoS will of course be "n" in these cases (e.g. <t pos="n" gender="f"> <t pos="n" number="pl">)

  ==> TODO


6. solved
-----------------
Problem: Kommas innerhalb von Klammern trennen keine <t>-Elemente
these commas are all replaced by COMMA already
-----------------

  ==> done

7. conversion of parentheses inside <t>
if the text in parentheses start with the word "о" it is most likely a <re>, e.g.
<t>выделаться (о шкуре)</t>
is to be converted into -->
<re>о шкуре</re>
<t>выделаться</t>
if the text in parentheses start with the word "напр." it is most likely a <te>, e.g.
<t>надраивание</t>
<t>натирка (напр. полов)</t>
is to be converted into -->
<t>надраивание</t>
<t>натирка</t>
<te>напр. полов</te> (@cip: As an interim solution, I will put this
into some attributes to the t-element under scrutiny!!! This is
because of the unclear status of te-element in the gt_dict.)

  ==> TODO

8. grammatical indicators inside <t>
ж F(emininum)
м M(asculinum)
с N(eutrum)
мн. Pl(uralis)
e.g.
<t>боль ж (душевная)</t>
<t>дождь м</t>
<t>будни мн.</t>
most of them are already tagged as F_GENDER, PL_NUMBER, etc.

  ==> TODO

9. aspect pairs in <t>
are always marked by / , perfective aspect seems always to be first, e.g.
<t>покрывать / покрыть</t>
is to be converted into -->
<t aspect="perf">покрывать</t>
<t aspect="imperf">покрыть</t>
a following parenthesis (<re> or <te>) has scope on the whole <tg>, e.g.
<t>убегать / убежать (о супе, молоке при кипении)</t>
is to be converted into -->
<re>о супе, молоке при кипении</re>
<t aspect="perf">убегать</t>
<t aspect="imperf">убежать</t>

  ==> TODO

===============

-wenn es mehrere Bedeutungen gibt (im Sinne von unseren <mg>), habe ich die Nummerierung der Übersetzungen aus dem Original behalten (tnumber=.…). Die Autoren des Originalwörterbuches haben sich wahrscheinlich bei der Reihenfolge der verschiedenen Bedeutungen etwas gedacht. Deshalb wollte ich gern diese Angabe behalten.
+wenn es mehrere "nahe Übersetzungen" gibt, sind diese innerhalb des Elements <T> mit Komma getrennt…
+wenn es mehrere "entferntere Übersetzungen gibt, sind diese innerhalb des Elements <T> mit Semikolon getrennt…
+wenn es russische Aspektpaare innerhalb des Elements <T> gibt, sind diese mit Slash getrennt, z.B. <T tnumber="1">кусать, укусить кого-что ; откусывать / откусить что, чего</T>

-warum haben <re>, <te>, <tf>, <xt> kein Sprachattribut, aber <t>
 schon (z.B. xml:lang="nob")? Wenn wir schon wissen, dass es
 sma<-->nob ist brauchen wir eigentlich gar keins. Aber wenn wir
 zeigen wollen, dass der folgende Text zu einer bestimmten Sprache
 gehört, ist das für <xt> usw. doch auch relevant. @cip: ich habe
 gelernt, flexibel damit zu sein. Wir werden sehen, wie sich das
 kristalliesiert, wenn wir wirklich in Richtung Cip's dream gehen.


Hier sind die Muster von den gemischten Knoten.
sjdrus>grep '<todo ' output_kt2gt/kurutch1985_1-1000.xml | sort | uniq -c | sort -nr  
 171          <todo n_pattern="txt_tam">
 108          <todo n_pattern="txt_tam_tam">
  36          <todo n_pattern="re_txt">
  14          <todo n_pattern="re_txt_tam">
   6          <todo n_pattern="re_txt_tam_tam"
--------------------------------------
   4          <todo n_pattern="txt_link"> (darueber haben wir jetzt geredet)
-->these are two different problems, which I fixed manually
-->1)since the scopus of the first of these "links" is the lemma and since it gives grammatic information I've created a new element for these things: <DER> =derivation; this new element belongs to <lg>, e.g.
<DER type="STRAD_K">балъе</DER>
and reads as follows:
DER of the type "strad_k" of the verb "балъе"
-->2)for the other "link" I've also created a new element in <lg>:
<COMPARE>; it points to another lemma with the same meaning,
e.g. <COMPARE>камаша</COMPARE>

@cip: if the t-element has the value "xxx" this solution is fine but
if not then there is a scope problem: is this information in addition
to whatever is the t-element translation or not?  If not does that
mean to create a new meaning group with a new tg and a new t
especially for this pointer? If yes how to display it (possible
problem: there might be several translation groups divided by
semicolon -- at the momet, I am working just with the first file)

	<E kur_ID="276">
		<L>БОТИНКА</L>
		<STEM>о.ч.</STEM>
		<CLASS>IV</CLASS>
		<POS/>
		<COMPARE>камаша</COMPARE>
		<T>ботинки PL_NUMBER (ед. ботинок M_GENDER)</T>
		<X>вуэссьтэ о̄дт ботинкатҍ </X>
		<XT>купить новые ботинки</XT>


Best example of underspecification wrt. this pointer:

	<E>
		<L>выннлэнне</L>
		<COMPARE>вынна</COMPARE>
		<T tnumber="1">косо, криво ; наклонно</T>
		<T tnumber="2">навстречу друг другу (наискосок)</T>
		<X>выннлэнне мэ̄нэмь, ка̄нҍц ка̄ннцан ебпь то̄ммтма</X>
		<XT>[мы] навстречу друг другу шли, а друг друга не узнали</XT>
	</E>
	<E kur_ID="925">

What should I compare to вынна: the first mg (косо, криво ; наклонно),
the first tg from the first mg (косо, криво), the first t of the first tg of
the first mg (косо), and so on?

The same hold also for <DER>-elements.

@cip: as agreed on 08.03.2011, this will be underspecified outside the mg groups 

--------------------------------------
   2          <todo n_pattern="sem_txt"> (??? --> take a look!)
--> this belongs to the element <SEM> = semantics, e.g. MEDicine, RELigion; scopus should be the meaning group; you have created this element "semantics" already with xxx, for a few entries (like these) a value is given in the dict 
--------------------------------------
   2          <todo n_pattern="pos_txt">  (??? --> take a look!)
-->fixed manually (lexicographically odd entry in the original dict (one lemma which is both adverb and postposition; I made two entries)
--------------------------------------
   1          <todo n_pattern="txt_tam_txt_tam">  (check scope of tam!)
-->fixed manually (lexicographically odd entry in the original dict (one meaning group with different meanings; I made two meaning groups)
--------------------------------------   
   1          <todo n_pattern="txt_tam_txt"> (check scope of tam!)
-->fixed manually (mistake in my original tagging)
--------------------------------------
   1          <todo n_pattern="txt_tam_tam_tam">
-->just one more tam as compared to "re_txt_tam_tam" above
--------------------------------------
   1          <todo n_pattern="txt_saam_link_txt_class_txt">   (??? --> take a look!)
-->fixed manually (lexicographically odd entry in the original dict: one entry with two lemmas; I made two entries)
--------------------------------------
   1          <todo n_pattern="re_txt_tam_tam_tam">
-->just one more tam as compared to "re_txt_tam_tam" above

===================================

sjdrus>grep '<todo ' output_kt2gt/kurutch1985_1-1000.xml | sort | uniq -c | sort -nr   173          <todo n_pattern="txt_tam">
 108          <todo n_pattern="txt_tam_tam">
  36          <todo n_pattern="re_txt">
  14          <todo n_pattern="re_txt_tam">
   6          <todo n_pattern="re_txt_tam_tam">
   2          <todo n_pattern="sem_txt">
   1          <todo n_pattern="txt_tam_tam_tam">
   1          <todo n_pattern="re_txt_tam_tam_tam">

===================================

refinements on parsing mixed content stuff:

sjdrus>grep '<todo ' output_kt2gt/kurutch1985_1-1000.xml | grep -v X1 
         <todo stamp="re_txtX2">
         <todo stamp="re_txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam_tam">

This is important: please check whether the scope of tam and re is ok
in these cases, Michael!

===================================
Is # ok in the T-element? I thought that # is the special sign marking
the idioms. Please check!

	<E>
		<L>воаррдэ</L>
		<STEM/>
		<CLASS>III</CLASS>
		<POS/>
		<T># бывать, побывать (где-л.)</T>
		<X>воаррдэ клӯбпе, библиотекая</X>
		<XT>бывать в клубе, в библиотеке</XT>
	</E>
	==> DONE

====================================
TODO: check T-elements with mixed node types as children: both
text-nodes and LINK-element nodes.
 - parse mixed content along the lines for examples with # marking for idioms
====================================

