Kurutch sjd-rus


Observation when working with the interim file:

1. Is there a crucial difference between ___TE and ___te or are these just the same in meaning?

         <tg>
            <t>боль F_GENDER ___TE душевная TE___</t>
         </tg>
         <tg>
            <t>страдание</t>
         </tg>
         <xg type="xxx">
            <x>а̄бьесьт е̄лле</x>
            <xt>жить с обидой ___te в душе te___</xt>
         </xg>


src>grep '___TE' interim_kurutch1985_sjdrus.xml | wc -l 
     118
src>grep '___te' interim_kurutch1985_sjdrus.xml | wc -l 
       6

Aha, just "spellrelax"?

kurutch>grep '___TE' * | wc -l 
     124
kurutch>grep '___te' * | wc -l 
       0

Something is not quite correct: 

         <xg type="xxx">
            <x>а̄бьесьт е̄лле</x>
            <xt>жить с обидой ___te в душе te___</xt>
         </xg>

These are in the example-context and I just copy the content of the examples without doing anything special.
==> DONE

==================
Very important to check what happened with the ot-entries after transformation
into a gt-like format!!!
@micha: the transformation went fine! I checked the interim file. only that there is no <lot> daughter of <r>. do we still need the "ot-merging test file"?
@cip: Yes? I definitely have to check that! I really have to check what I did months ago. But I think you are right, I did unified the ot-entries.
Hehe, naturally, there is no lot-element there because I did in fact merged the stuff and I switched off the output of this variable because it was
not needed any longer. Ergo: no need of any ot-merging test file.

OT-problem debugging:
kurutch>grep '<E' * | wc -l 
   13577
kurutch>grep '<E>' * | wc -l 
    5712
kurutch>grep '<E ' * | wc -l 
    7865
kurutch>grep -h '<E' *xml | grep 'kur_ID' | grep '\-1' | wc -l 
      20
kurutch>grep -h '<E' *xml | grep 'kur_ID' | grep '\-2' | wc -l 
      20
kurutch>grep 'TYPE="OT"' *  | wc -l 
     308


src>grep '<e' interim_kurutch1985_sjdrus.xml | wc -l 
   13273
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep 'link' | wc -l 
    5657
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep -v 'link' | wc -l 
    7616
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep -v 'link' | grep 'xxx' | wc -l 
    5712
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep -v 'link' | grep -v 'xxx' | wc -l 
    1904
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep '\-1' | wc -l  
      18
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep '\-2' | wc -l  
      18
<r xml:lang="sjd" no-link_e="7616" ot_e="304" sm_e="5657">

308 ot in input but just 304 in output? 20 ID split in NO-1 and NO-2 but only 18 in the output?
Is there something wrong? No, they landet inside the kur_stem element after the ot-merging.

 ==> done
==================

=======================================

2. MERGE RULE1 (LINK TYPE="OT"), look at the following example
1st entry
	<E kur_ID="58">
		<L>АДЖЬ</L>
		<STEM>ажь</STEM>
		<CLASS>I,1</CLASS>
		<POS/>
		<T>отец</T>
#
<X>ажьнӣййт</X>
		<XT>оленёнок (самка) или важенка, подаренная отцом (напр. дочери на свадьбу)</XT>
	</E>

2nd entry	
	<E kur_ID="69">
		<L>ажь</L>
		<T>
			<LINK TYPE="OT">аджь</LINK>
		</T>
	</E>



result:

	<E kur_ID="58">
	   <lg>
		<L>АДЖЬ</L>
		<STEM kur_ID="69">ажь</STEM>
		<CLASS>I,1</CLASS>
		<POS/>
        </lg>
		<T>отец</T>


	
-to be merged in a way, that the kur_ID remains in the <infl_group> (see task above): <kur_stem kur_ID="x"
		

Analysis before unification:
sjdrus>grep '<ot_test ' output_kt2gt/kurutch1985_1-1000.xml | sort | uniq -c | sort -nr 
  28          <ot_test stamp="l_t">
   2          <ot_test stamp="l_der_t">
   1          <ot_test stamp="l_t_t">
sjdrus>grep '<sm_test ' output_kt2gt/kurutch1985_1-1000.xml | sort | uniq -c | sort -nr 
 679          <sm_test stamp="l_t">
   1          <sm_test stamp="l_t_t">


@cip: Micha, take a look at these two entries:
   2          <ot_test stamp="l_der_t">

      <E kur_ID="49" link_ot="1" link_sm="0">
        <L>агка</L>
         <DER type="DIM">а̄һкь</DER>
         <T>
            <LINK TYPE="OT">а̄ка</LINK>
         </T>
      </E>

      <E kur_ID="816" link_ot="1" link_sm="0">
        <L>вуэла</L>
         <DER type="DIM">вӯлльгесь</DER>
         <T>
            <LINK TYPE="OT">вуэлэнч</LINK>
         </T>
      </E>

Question: What to do with the <DER>-slot?
@Micha: Cip, <DER> should stay in <lg>
<lg>
…
<l>а̄ка</l> <---this comes from <LINK> (this is pretty clear.)
<infl>
<kur_stem kur_ID="49" case="nom" number="pl">агка</kur_stem> <---this
comes from <L> ( this is pretty clear.)
</infl>
<DER type="DIM">а̄һкь</DER> <---this comes from <DER>
… (This is now clear.)
</lg>

The rest is pretty clear.
    
    
    
@cip: This is to be checked. Some have the index problem attached to the
L-value of an LINK OT entry, some lack diacritica. The interim file
will be checked in.

sjdrus>grep '_conf' _out/kurutsch_interim.xml 
sjdrus>grep '_conf' _out/kurutsch_interim.xml 
            <kur_stem kur_ID="xxx_conflict_xxx" case="nom" number="pl">рӯц</kur_stem>
            <kur_stem kur_ID="xxx_conflict_xxx" case="nom" number="pl">рӯц</kur_stem>
            <kur_stem kur_ID="xxx_conflict_xxx" case="nom" number="pl">тугк</kur_stem>
            <kur_stem kur_ID="xxx_conflict_xxx" case="nom" number="pl">тугк</kur_stem>
            <kur_stem kur_ID="xxx_conflict_xxx" case="nom" number="pl">э̄д</kur_stem>


@cip: indices in an L-element of the LINK OT type do not make sense,
and as one can see here, they just make truble for processing.

kurutch>grep '>рӯц\-1\,\-2<' *.xml 
kurutch1985_5001-6000.xml:		<L xxx="please_correct_me">рӯц-1,-2</L>

 ==> the conflict problems are now done
 
 @cip: DERivation element checked in all three types of entries before
 merging: no danger of overwriting, merging can be done just as a
 copying of DER element from the LINK OT entry into the content entry,
 without any further checks
	
 Sub-task: merge the info in the DER-element of the LINK OT entry with
	that from the pendant content entry.

      ==> done

@cip: note for myself: 
-<r xml:lang="sjd" no-link_e="7602" ot_e="302" sm_e="5660">
+<r xml:lang="sjd" no-link_e="7603" ot_e="303" sm_e="5666">

Michael has done some changes that affected also the number of LINK OT
entries, so I have to turn on the LINK OT test anew. ==> no need for
that, I debugged the OT-issue now and it was like that (see above).


Testing input-output of the sm-merging operation:
Input:

All entries:
src>grep '<e' interim_kurutch1985_sjdrus.xml | wc -l 
   13273

Entries that have a link_sm, i.e. with ID but without real content:
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep 'link' | wc -l 
    5657

Entries that don't have a link_sm (some of them would merge some of them not):
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep -v 'link' | wc -l 
    7616

Entries that most probably merge because they have not kur_ID just a fake one:
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep -v 'link' | grep 'xxx' | wc -l 
    5712

Entries that most problably don't merge because they don't have a fake kur_ID:
src>grep '<e' interim_kurutch1985_sjdrus.xml | grep -v 'link' | grep -v 'xxx' | wc -l 
    1904


Output:

All entries:
merge_output>grep '<e' out_interim_kurutch1985_sjdrus.xml | wc -l 
    7616

SM-Merged entries:
merge_output>grep '<e' out_interim_kurutch1985_sjdrus.xml | grep link_sm | wc -l 
    5657

Non-merged entries:
merge_output>grep '<e' out_interim_kurutch1985_sjdrus.xml | grep -v link_sm | wc -l 
    1959

Non-merged entries with real ID:
merge_output>grep '<e' out_interim_kurutch1985_sjdrus.xml | grep -v link_sm | grep -v 'xxx' | wc -l 
    1904

Non-merged entries with fake ID xxx:
merge_output>grep '<e' out_interim_kurutch1985_sjdrus.xml | grep -v link_sm | grep 'xxx' | wc -l 
      55

Same number of lind_sm entries: 5657 (ok)

7616 - 5657= 1959 ==> this is the number in the output of non-merged entries (ok)

Non-merged number of entries with real ID: 1904 (ok)

Non-merged number of entries with fake ID xxx: 55

Test bestanden! 

I will let the link_sm-flag on the e-element for a while, in the final step I will remove it.

================================

@cip: proper tests before merging of LINK SM entries:

First test: It the mapping of LINK SM entries into content entries exhaustive?

From a total of 5659 LINK SM entries:

   sjdrus>grep '<merge_target' _out/kurutsch_interim.xml | wc -l 
       5659

there are 5485 LINK SM entries that have exactly one T element and
some corresponent content entry has been found for the same L string:

   sjdrus>grep '<merge_target t_count="1">' _out/kurutsch_interim.xml | wc -l 
       5485

there are 6 LINK SM entries that have exactly two T elements and
some corresponent content entry has been found for the same L string:

   sjdrus>grep '<merge_target t_count="2">' _out/kurutsch_interim.xml | wc -l 
       6

BUT ... for 168 LINK SM entries there is no correspondent content
entry found:

   sjdrus>grep '<merge_target t_count="1"/>' _out/kurutsch_interim.xml | wc -l 
        168

For the sake of completness, I did this test too: there is no LINK SM
   with two T elements but lacking a content entry:

   sjdrus>grep '<merge_target t_count="2"/>' _out/kurutsch_interim.xml | wc -l 
        0

Addition test: 6 + 168 + 5485 = 5659 (the total sum of LINK SM
entries, i.e. nothing missed)

Ergo: The mapping is not exhaustive.
Problematic cases: 168 LINK SM entries without match (check for wrong
spelling, weird indices, etc.)

Second test: Is the mapping of LINK SM entries unambiguous? Micha
aluded to ambiguosity when doing string comparison (see MERGE RULE 2 below).

For the total of 5485 single links and  6 double links that have
corresponding content entries, there should be 5485 + 12 = 5497
content entry pointers.

The number found is 5501, there is some ambiguosity but manually correctable
   sjdrus>grep '<sm_target' _out/kurutsch_interim.xml | wc -l 
       5501

Mark the ambiguous cases
     ==> done

Here is the improved test:

sjdrus>grep '<merge_target' _out/kurutsch_interim.xml | sort | uniq -c | sort -nr 
5481          <merge_target t-element_count="1" link-match_count="1">
   ===> ideal cases 
 168          <merge_target t-element_count="1" link-match_count="0"/>
   ===> problematic cases: LINK SM entries without corresponding
   	      content entries (typos, weird indices, etc.)
   6          <merge_target t-element_count="2" link-match_count="2">
   ===> ideal cases (I assume that) 
   4          <merge_target t-element_count="1" link-match_count="2">
   ===> ambiguous cases: these have to be checked and corrected manually 

Test done 17.05.2011:

sjdrus>grep '<merge_target' src/interim_kurutch1985_sjdrus.xml | sort | uniq -c | sort -nr 
5517          <merge_target t-element_count="1" link-match_count="1">
 136          <merge_target t-element_count="1" link-match_count="0"/>
   6          <merge_target t-element_count="2" link-match_count="2">
   1          <merge_target t-element_count="1" link-match_count="2">


Test done 19.05.2011:
sjdrus>grep '<merge_target' src/interim_kurutch1985_sjdrus.xml | sort | uniq -c | sort -nr 
5630          <merge_target t-element_count="1" link-match_count="1">
  36          <merge_target t-element_count="1" link-match_count="0"/>

Ergo: only 36 problematic entries!
@Micha: should be fixed now

Test done 22.05.2011:
sjdrus>grep '<merge_target' src/interim_kurutch1985_sjdrus.xml | sort | uniq -c | sort -nr 
5657          <merge_target t-element_count="1" link-match_count="1">
@cip: Indeed! This means that I can begin merging them as described in
the specifications.


@cip: All checks should be done in the interim-file. Answer to Micha's
email: In order to check the ambiguous entries, go the the interm-file
and find the pattern:

  <merge_target t-element_count="1" link-match_count="2">

That means: For the (normalized= lower-cased) string in L-element of the
LINK SM entry ( t-element_count="1"), there are two content entries
that match (link-match_count="2").

Here is the first of the four ambiguous cases from the interim-file:

      <e kur_ID="508" link_sm="1">
         <t_with_sm_test stamp="link_">
            <node ntype="link">вӣрр</node>
         </t_with_sm_test>
         <merge_target t-element_count="1" link-match_count="2">
            <sm_target kur_ID="xxx">вӣрряй</sm_target>
            <sm_target kur_ID="xxx">вӣрряй</sm_target>
         </merge_target>
         <l>вӣрряй</l>
         <t>
            <link type="SM">вӣрр</link>
         </t>
      </e>


@cip: There are no T-elements in LINK SM entries that contain mixed
nodes, i.e., both text nodes and element nodes:

   sjdrus>grep '<t_with_sm_test stamp' _out/kurutsch_interim.xml | sort | uniq -c | sort -nr 
   5665          <t_with_sm_test stamp="link_">

     
3. MERGE RULE 2 (LINK TYPE="SM")
merge of original reference entries (i.e. having a kur_ID) with content entries (i.e. without ID) 
trigger: string (watch out for ambiguities)

to be solved according to the following rules
-find two entries of the following type
1st entry:
   <E kur_ID="3">
		<L>аббрай</L>
		<T>
			<LINK TYPE="SM">аббьр</LINK>
		</T>
	</E>
2nd entry:
	<E>
		<L>аббрай</L>
		<POS>PRED</POS>
		<T>дождливый, дождлив</T>
		<X>ке̄ссь ля̄йй аббрай</X>
		<XT>лето было дождливым</XT>
	</E>
-these entry pairs always:
++have two similar contents in <L>
++1st entry has a kur_ID, 2nd entry doesn't
++1st entry has a mixed T-element with text and LINK children, 2nd entry doesn't

(@cip: Really? I don't belive that, ergo: I have to check it! --- checked and found out that they contain only LINK-elements)

-merge these two entries into one entry, as in the following example
   <E kur_ID="3">  kur_ID="id_01;id_02;id_03"
		<L>аббрай</L>
		<POS>PRED</POS>
		<DER type="SM">аббьр</DER>
		<T>дождливый, дождлив</T>
		<X>ке̄ссь ля̄йй аббрай</X>
		<XT>лето было дождливым</XT>
	</E>
	


@cip: followup question
Have a look at these entries that have to be merged:

        <E kur_ID="6464">
                <L>тыввлуввэ</L>
                <T>
                        <LINK TYPE="SM">тыввнэдтэ</LINK>
                </T>
        </E>

        <E>
                <L>тыввлуввэ</L>
                <CLASS>I</CLASS>
                <COMPARE>тыввнэдсэ</COMPARE>
                <T>xxx</T>
        </E>

My script all_kurutchorit2gt.xsl does the following:

	    <xsl:if test="./*[(local-name() = 'DER') or (local-name() = 'COMPARE')]">
	      <pointers>
		<xsl:for-each select="./*[(local-name() = 'DER') or (local-name() = 'COMPARE')]">
		  <xsl:element name="{lower-case(local-name(.))}">
		    <xsl:copy-of select="./@*"/>
		    <xsl:copy-of select="normalize-space(lower-case(.))"/>
		  </xsl:element>
		</xsl:for-each>
	      </pointers>
	    </xsl:if>

... that means it creates a pointers-element like that:

   <e kur_ID="xxx">
      <lg>
         <l pos="v">тыввлуввэ</l>
         <infl>
            <kur_infl class="I" ablaut="_x_" special="_x_"/>
         </infl>
         <pointers>
            <compare>тыввнэдсэ</compare>
         </pointers>
      </lg>
      <mg km="g">
         <semantics>
            <stype>xxx</stype>
         </semantics>
         <tg>
            <t>xxx</t>
         </tg>
      </mg>
   </e>

When I merge that with the SM-entrie the result ist that:

   <e kur_ID="6464" link_sm="1">
      <lg>
         <l pos="v">тыввлуввэ</l>
         <infl>
            <kur_infl class="I" ablaut="_x_" special="_x_"/>
         </infl>
         <pointers>
            <compare>тыввнэдсэ</compare>
         </pointers>
         <der type="SM">тыввнэдтэ</der>
      </lg>
      <mg km="g">
         <semantics>
            <stype>xxx</stype>
         </semantics>
         <tg>
            <t>xxx</t>
         </tg>
      </mg>
   </e>

Question: Is the information in the pointers-element not superfluous that means exactly the same
as that comming from the SM-entry? Can I just ignore it or could it be that there are entries with
pointer-elements different than the SM/OT info?

@micha: what you did was all right! yes, pointer-elements should be different the SM/OT info, like in this example here ( тыввнэдсэ vs. тыввнэдтэ ).


Caveat:
1. merge of several SM entries
grep '<link type="SM">' interim_kurutch1985_sjdrus.xml | sort | uniq -c | sort -nr | less
2. no doubled entries after merging, i.e., just copy the entries that are not string-equal with
some SM or OT link.

Debugging the sm-merging operation with the test file:

sjdrus>grep '<e' rule2_merging_test.xml | wc -l 
      24
sjdrus>grep '<e' rule2_merging_test.xml | grep link_sm | wc -l 
      10
sjdrus>grep '<e' rule2_merging_test.xml | grep -v link_sm | wc -l 
      14

Assumption: the result file should contain the four entries that don't have to merge plus
the ten sm-unified entries.

	==> DONE (to check the results and merge the whole file)

====================
7. ASPEKT PAIRS
aspect pairs in <t> are always marked by / (slash), perfective aspect occurrs always as the first element, e.g.
<t>покрывать / покрыть</t>
is to be converted into -->
<t aspect="perf">покрывать</t>
<t aspect="imperf">покрыть</t>

Problem: sometimes in <t> there is more info than just die aspect verb pair, like
<t>VERBperf / VERBimperf WORD (EXPLANATION)</t>
However, I believe there is always only the VERBperf before the opening tag <t> and the / (slash). If this is true, the / (slash) has always scopus over the two words surrounding it.

@Micha: lexicographic question: we have
<mg>
	<tg>
		<t>
		</t>
	</tg>
</mg>
Are the aspect pairs sisters in <tg> (<t1><t2>), or aren't they rather sisters one level under <t>?


Preliminary tests:

1. The pattern:
src>grep '/' sm-unified_kurutch1985_sjdrus.xml | grep ' /' | wc -l  
     738
src>grep '/' sm-unified_kurutch1985_sjdrus.xml | grep '/ ' | wc -l  
     740
src>grep '/' sm-unified_kurutch1985_sjdrus.xml | grep ' / ' | wc -l  
     736
src>grep '/' sm-unified_kurutch1985_sjdrus.xml | grep '/ ' | grep -v ' / ' 
            <t>защищать/ защитить кого-что</t>
            <t>распарывать/ распороть</t>
            <t>срыгивать/ срыгнуть что</t>
            <t>разрезать/ разрезать что</t>
src>grep '/' sm-unified_kurutch1985_sjdrus.xml | grep ' /' | grep -v ' / ' 
            <t>затыкать /заткнуть что чем</t>
            <t>расти /вырасти</t>
            ==> DONE <== (all are ' / ')            

2. Inconsistencies:

<t>перегонять / перегнать кого ___TE куда-л. TE___</t>
vs.
<t>загонять / загнать кого (куда-л.)</t>

In the same greater context, the pattern "куда-л."  appears both
in __TE TE__ and in () smaller contextes. Is there a reason why?

@micha: no reason, for this "куда-л." there has yet to be find a place in my dict-structure :-(

3. Scope of material immediately following the pattern ASPECT_1 / ASPECT_2:
 INPUT:
            <t>закупать / закупить что</t>
 OUTPUT:
            <t>закупать что</t>
            <t>закупать что</t>

4. Scope of material immediately preceding the pattern ASPECT_1 / ASPECT_2:
INPUT:
	<t>___ÜBERTRAGEN___ переворачивать / перевернуть что</t>
OUTPUT:
	<t>___ÜBERTRAGEN___ переворачивать что</t>
	<t>___ÜBERTRAGEN___ перевернуть что</t>

Clue: 

   First, solve the issues that take scope over aspect-operator, then
   the aspect issue, otherwise one has to copy (i.e., double) all
   information to both aspect elements.

   Another soution is just to pick one element of the aspectual pair
   as the content of the t-element, and the other can be stored as an
   attribute to the respective t-element. This would be a
   (linguistically perhaps weird but at least implementationswise)
   clean solution to the lexicographic question added by @micha above.

 Example:
   <t pos="v" perf="переворачивать">___ÜBERTRAGEN___ переворачивать что</t>

@micha: yes, this is a good solution (for now)!
INPUT:
<t>покрывать / покрыть</t>
OUTPUT:
<t pos="v" imperf="покрыть">покрывать</t>

INPUT:
<t>___ÜBERTRAGEN___ покрывать / покрыть что</t>
OUTPUT:
<t pos="v" imperf="покрыть">___ÜBERTRAGEN___ покрывать что</t>
  
iChat-quotation: "Michael Rießler
die erste form ist die grundform, die zweite das attribut"
 
@cip: Ok, but I just want to point to somenthing that migh call for the reverse,
namely the first part as attribute and the second as baseform.
I don't have any idea about Russian, this is just by observing some pattern.

Look at these examples:
<tg>
   <t>греть кого-что</t>
   <t>согревать / согреть кого-что</t>
</tg>

<tg>
  <t>греть что</t>
  <t>нагревать / нагреть что</t>
  <t>разогревать / разогреть что</t>
</tg>

<tg>
  <t>топить что</t>
  <t>отапливать / отопить что</t>
  <t>обогревать / обогреть что</t>
</tg>

<tg>
  <t>лить что</t>
  <t>наливать / налить что</t>
</tg>

<tg>
  <t>тесать что</t>
  <t>обтёсывать / обтесать что</t>
</tg>

<tg>
  <t>мешать что</t>
  <t>размешивать / размешать что</t>
  <t>перемешивать / перемешать что</t>
</tg>

the result as you wanted would be:

<tg>
   <t>греть кого-что</t>
   <t imperf="согреть кого-что">согревать</t>
</tg>

<tg>
  <t>греть что</t>
  <t imperf="нагреть">нагревать что</t>
  <t imperf="разогреть">разогревать что</t>
</tg>

Pattern inconsistency:
 the basform without aspect pair is a non-ва-suffix form while
 the baseform with aspect pair is a ва-suffix form.

As I said, this is based on pattern, I don't know the meaning of the prefixes
that discriminate the different non-ва-suffix forms within the same
translation group such as мешать, размешать, and перемешать.

Problem: ambiguous slash content detected, i.e., a t-element whith two slashes!!!
 
sjdrus>grep 'counter' polish_output/out_sm-unified_kurutch1985_sjdrus.xml | sort | uniq -c | sort -nr 
 742             <counter>2</counter>
   1             <counter>3</counter>



  ==> TO DO

==================
8. GENDER/NUMBER TAGS
the tags x_GENDER (z.B. F_GENDER, etc.) x_NUMBER (z.B. PL_NUMBER, etc.) should be transfered into an attribute of <t>;

  ==> TO DO

====================================
4. LEXICON GROUP
there is a lot of comprehensive lexicon-like information included in the translations, these should go into a new group under <mg>
rule: convert text between the tags ___LEXICON x LEXICON___ into 
<mg>
<lex_group>
<lexicon>x</lexicon>
</lex_group>
</mg>
Example
<e kur_ID="6674">
      <lg>
         <l pos="MEZHD">уш-уш-уш</l>
      </lg>
      <mg km="g">
         <semantics>
            <stype>xxx</stype>
         </semantics>
         <lex_group>
         <lexicon>возглас при ощущении холода</lex>
         </lex_group>
         <tg>
            <t>ой!</t>
            <t>ух!</t>
         </tg>
      </mg>
   </e>
But note, that the LEXICONtag can also occur inside <XT> (example). For now we need the vonversion only for the <T> LEXICON </T>
	<E kur_ID="58">
		<L>АДЖЬ</L>
		<STEM>ажь</STEM>
		<CLASS>I,1</CLASS>
		<POS/>
		<T>отец</T>
#
<X>ажьнӣййт</X>
		<XT>___LEXICON оленёнок (самка) или важенка COMMA подаренная отцом COMMA напр. дочери на свадьбу LEXICON___ </XT>
	</E>

@Micha: Note that a subpart of the LEXICON entried are flagged for the Lovozero training (LEXICON_LOV)	
   
  ==> TO DO


==================
5. RE GROUPS
5a. conversion of parentheses inside <t>
if the text in parentheses start with either the word "(о " or "(об " it should be converted into an <re> element with scope on <tg>

	==> CAN WAIT (@micha: I'll rather do this manually during later edition of the dict)

5b. a few other <re>s (formely in parentheses inside <t>) have been tagged manually as ___RE x RE___ and should likewise be converted into an <re> element with scope on <tg> (see above)

	==> CAN WAIT (@micha: I'll rather do this manually during later edition of the dict)
	
==================
6. TE GROUPS	
5a.if the text in parentheses start with the word "(напр. " it should be converted into an <te> element with scope on <tg>
(@cip: As an interim solution, I will put this
into some attributes to the t-element under scrutiny!!! This is
because of the unclear status of te-element in the gt_dict.)

    ==> CAN WAIT (@micha: I'll rather do this manually during later edition of the dict)

6b. a few other <te>s (formely in parentheses inside <t>) have been tagged manually as ___TE x TE___ and should likewise be converted into an <te> element with scope on <tg> (see above)

	==> CAN WAIT (@micha: I'll rather do this manually during later edition of the dict)
	

=============================================
9. DIFFERENT THINGS (TO THINK ABOUT…)

(z. 324: scopus mg-element, according to our discussion from 08.03.2011) 
<RE>PRJAM,PEREN</RE> / <RE>PRJAM_PEREN</RE> / <RE>PEREN</RE> / etc.
Scope remains as we discussed, but I have re-tagged this element (because <RE> is needed for another element)
___VERSCH_BED___ Scope is mg
___ÜBERTRAGEN___ Scope is mg (<-- <RE>PEREN</RE>)
___AUCH_ÜBERTRAGEN___ Scope is mg (<-- <RE>TOZHE_PEREN</RE>)
___WÖRTLICH+ÜBERTRAGEN___ Scope is mg (<-- <RE>PRJAM_PEREN</RE>)
 ==> CAN WAIT (@micha: I'll rather do this manually during later edition of the dict)
 
the preliminary tag LOOKUP marks a pointer to Kildin words in Russian text elements, e.g.
выделывать / выделать (шкуру крюком ___LOOKUPкрӯһкь___LOOKUP)
this should somehow be converted into a link inside the final dict, like
выделывать / выделать (шкуру крюком <LOOKUP xml:lang="sjd">крӯһкь</LOOKUP>

  ==> CAN WAIT (@micha: I'll rather do this manually during later edition of the dict)


==> DONE <==
2. gt_dict structure: mapping like in the following example:
   
<e kur_ID="xxx">
	<lg>
		<l pos="xxx">xxx</l>
		<STEM>xxx</STEM> (1-100: z. 55)
		<CLASS>xxx</CLASS> (1-100: z. 56)
	</lg>
	<mg>
     	<semantics>
			<sem class="xxx"/>
		</semantics>

     <tg>
==> DONE <==
		 (1-100: z. 72, komma mapped on different t-elements)   ==> done
		 
         (1-100: z. 1348, semicolon mapped on different tg-elements)   ==> done
		 
		 (z. 136: different meaning groups: @cip: relevant order???) @micha: order was probably relevant for the authers of the original dict; wenn es mehrere Bedeutungen gibt (im Sinne von unseren <mg>), habe ich die Nummerierung der Übersetzungen aus dem Original behalten (tnumber="x"). Die Autoren des Originalwörterbuches haben sich wahrscheinlich bei der Reihenfolge der verschiedenen Bedeutungen etwas gedacht. Deshalb wollte ich gern diese Angabe behalten. ==> done
		 
TAM-element = grammar info (aspect, etc.); scopus is mg-element
(according to our discussion from 08.03.2011)!!!   ==> done

examples of <x> with several translations:
(101-500: z. 3258)
		<X>ва̄лльтэ ва̄лт</X>
		<XT xtnumber="1">завоевать свободу</XT>
		<XT xtnumber="2">стать своевольным</XT>
			
            <xg type=idiom subtype=blabla>
				<x>xxx</x>
				<xt xml:lang="xxx">xxx</xt>
			</xg>
  ==> done

example for idiom subtype (idiom groups are preliminary marked by # preceeding the whole group; idioms are always at the end of an <e> or <mg> (no other <x> following them):		

<X>парна бальяк, шӯрран — лӯјкак</X>
		<XT>POSLOVICA [ребёнка] маленького балуешь - с большим плачешь</XT>

		</tg>
	</mg>
</e>

  ==> done

non-capitals in the element <L>

  ==> done
==> DONE <==


===============

-warum haben <re>, <te>, <tf>, <xt> kein Sprachattribut, aber <t>
 schon (z.B. xml:lang="nob")? Wenn wir schon wissen, dass es
 sma<-->nob ist brauchen wir eigentlich gar keins. Aber wenn wir
 zeigen wollen, dass der folgende Text zu einer bestimmten Sprache
 gehört, ist das für <xt> usw. doch auch relevant. @cip: ich habe
 gelernt, flexibel damit zu sein. Wir werden sehen, wie sich das
 kristallisiert, wenn wir wirklich in Richtung Cip's dream gehen.
 
===============

==> DONE <==
Hier sind die Muster von den gemischten Knoten.
sjdrus>grep '<todo ' output_kt2gt/kurutch1985_1-1000.xml | sort | uniq -c | sort -nr  
 171          <todo n_pattern="txt_tam">
 108          <todo n_pattern="txt_tam_tam">
  36          <todo n_pattern="re_txt">
  14          <todo n_pattern="re_txt_tam">
   6          <todo n_pattern="re_txt_tam_tam"
--------------------------------------
   4          <todo n_pattern="txt_link"> (darueber haben wir jetzt geredet)
-->these are two different problems, which I fixed manually
-->1)since the scopus of the first of these "links" is the lemma and since it gives grammatic information I've created a new element for these things: <DER> =derivation; this new element belongs to <lg>, e.g.
<DER type="STRAD_K">балъе</DER>
and reads as follows:
DER of the type "strad_k" of the verb "балъе"
-->2)for the other "link" I've also created a new element in <lg>:
<COMPARE>; it points to another lemma with the same meaning,
e.g. <COMPARE>камаша</COMPARE>

@cip: if the t-element has the value "xxx" this solution is fine but
if not then there is a scope problem: is this information in addition
to whatever is the t-element translation or not?  If not does that
mean to create a new meaning group with a new tg and a new t
especially for this pointer? If yes how to display it (possible
problem: there might be several translation groups divided by
semicolon -- at the momet, I am working just with the first file)

	<E kur_ID="276">
		<L>БОТИНКА</L>
		<STEM>о.ч.</STEM>
		<CLASS>IV</CLASS>
		<POS/>
		<COMPARE>камаша</COMPARE>
		<T>ботинки PL_NUMBER (ед. ботинок M_GENDER)</T>
		<X>вуэссьтэ о̄дт ботинкатҍ </X>
		<XT>купить новые ботинки</XT>


Best example of underspecification wrt. this pointer:

	<E>
		<L>выннлэнне</L>
		<COMPARE>вынна</COMPARE>
		<T tnumber="1">косо, криво ; наклонно</T>
		<T tnumber="2">навстречу друг другу (наискосок)</T>
		<X>выннлэнне мэ̄нэмь, ка̄нҍц ка̄ннцан ебпь то̄ммтма</X>
		<XT>[мы] навстречу друг другу шли, а друг друга не узнали</XT>
	</E>
	<E kur_ID="925">

What should I compare to вынна: the first mg (косо, криво ; наклонно),
the first tg from the first mg (косо, криво), the first t of the first tg of
the first mg (косо), and so on?

The same hold also for <DER>-elements.

@cip: as agreed on 08.03.2011, this will be underspecified outside the mg groups
==> DONE <==

=====================================
   2          <todo n_pattern="sem_txt"> (??? --> take a look!)
--> this belongs to the element <SEM> = semantics, e.g. MEDicine, RELigion; scopus should be the meaning group; you have created this element "semantics" already with xxx, for a few entries (like these) a value is given in the dict 
--------------------------------------
   2          <todo n_pattern="pos_txt">  (??? --> take a look!)
-->fixed manually (lexicographically odd entry in the original dict (one lemma which is both adverb and postposition; I made two entries)
--------------------------------------
   1          <todo n_pattern="txt_tam_txt_tam">  (check scope of tam!)
-->fixed manually (lexicographically odd entry in the original dict (one meaning group with different meanings; I made two meaning groups)
--------------------------------------   
   1          <todo n_pattern="txt_tam_txt"> (check scope of tam!)
-->fixed manually (mistake in my original tagging)
--------------------------------------
   1          <todo n_pattern="txt_tam_tam_tam">
-->just one more tam as compared to "re_txt_tam_tam" above
--------------------------------------
   1          <todo n_pattern="txt_saam_link_txt_class_txt">   (??? --> take a look!)
-->fixed manually (lexicographically odd entry in the original dict: one entry with two lemmas; I made two entries)
--------------------------------------
   1          <todo n_pattern="re_txt_tam_tam_tam">
-->just one more tam as compared to "re_txt_tam_tam" above

	==> done

===================================

sjdrus>grep '<todo ' output_kt2gt/kurutch1985_1-1000.xml | sort | uniq -c | sort -nr   173          <todo n_pattern="txt_tam">
 108          <todo n_pattern="txt_tam_tam">
  36          <todo n_pattern="re_txt">
  14          <todo n_pattern="re_txt_tam">
   6          <todo n_pattern="re_txt_tam_tam">
   2          <todo n_pattern="sem_txt">
   1          <todo n_pattern="txt_tam_tam_tam">
   1          <todo n_pattern="re_txt_tam_tam_tam">
   
   ==> done

===================================

refinements on parsing mixed content stuff:

sjdrus>grep '<todo ' output_kt2gt/kurutch1985_1-1000.xml | grep -v X1 
         <todo stamp="re_txtX2">
         <todo stamp="re_txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam">
         <todo stamp="txtX2_tam_tam">

This is important: please check whether the scope of tam and re is ok
in these cases, Michael!

		==> done

===================================
Is # ok in the T-element? I thought that # is the special sign marking
the idioms. Please check!

	<E>
		<L>воаррдэ</L>
		<STEM/>
		<CLASS>III</CLASS>
		<POS/>
		<T># бывать, побывать (где-л.)</T>
		<X>воаррдэ клӯбпе, библиотекая</X>
		<XT>бывать в клубе, в библиотеке</XT>
	</E>
	==> DONE


====================================

 - parse mixed content along the lines for examples with # marking for idioms
 testit : grep          <xg type="idiom"> in the output file
 ==> done
      
==> done <==
@micha: please check the "idiom group conversion rule" (the marker was #), perhaps something is wrong because now the examples occur twice
from the interim file:
@cip: not perhaps, sure... I found that in some stage I deleted parts of the code that were responsible for dat. I will fix it.

<e kur_ID="1">
      <lg>
         <l pos="xxx">а</l>
      </lg>
      <mg km="g">
         <semantics>
            <stype>xxx</stype>
         </semantics>
         <tg>
            <t>а</t>
         </tg>
         <xg type="xxx"> <<<=== right conversion
            <x>пуада эмм та̄рьм, а ента</x>
            <xt>[я] приду не сегодня, а завтра</xt>
         </xg>
         <xg type="xxx"> <<<=== right conversion
            <x>мунн лӣннче пӯдзэ пынньенҍ, а со̄нн ля̄ннч лӣхемь лаппьсъенҍ</x>
            <xt>я буду оленеводом, а она будет дояркой</xt>
         </xg>
         <xg type="sentence"> <<<=== right conversion
            <x>а ке̄ тоннӭ цӣӆькэ тэнн баяс?</x>
            <xt>а кто тебе сказал об этом?</xt>
         </xg>
         <xg type="idiom"> <<<=== wrong
            <x>пуада эмм та̄рьм, а ента</x>
            <xt>[я] приду не сегодня, а завтра</xt>
         </xg>
         <xg type="idiom"> <<<=== wrong
            <x>мунн лӣннче пӯдзэ пынньенҍ, а со̄нн ля̄ннч лӣхемь лаппьсъенҍ</x>
            <xt>я буду оленеводом, а она будет дояркой</xt>
         </xg>
         <xg type="idiom"> <<<=== wrong
            <x>а ке̄ тоннӭ цӣӆькэ тэнн баяс?</x>
            <xt>а кто тебе сказал об этом?</xt>
         </xg>
      </mg>
   </e>
==> done <==

==> DONE <==
INFLECTION GROUP

In Kurutch's dict two elements include info on infection:
<stem/> 
  (info on stem gradation [by giving the form for NOM.PL], only for nouns)

<class/> 
  (info on inflection [Roman numeral=class, 
   Arabic numeral=subclass (ablaut), 
   "*" (asterisk) marks some special gradation in verbs, 
   "," (comma) divides class and subclass from each other, 
   translate_linguist2normal("note that in all entries of the dict not all info must be present") 
  ==> this info is optional])

I do not find Kurutch's classes very useful and have to edit it later. However, her analysis should be kept.
I suggest creating an "inflection group" and converting the inflectional stuff as follows

a) (for nouns: i.e. those lemma for which info on <STEM> is provided)
<infl>
   <kur_stem kur_ID="xxx" case="nom" number="pl">x</kur_stem>
   <kur_infl class=" x " ablaut=" x " special=" x "/>
</infl>

b) (for verbs: i.e. those lemma for which there is no info on <STEM> provided)
<infl>
   <kur_infl class=" x " ablaut=" x " special=" x "/>
</infl>

(perhaps test the verb:noun differentiation an bases on the missing <STEM> first? according to the explanations in the original dict it should work though)

+ add a variable case="nompl" to the old <stem> element
+ rename the old <class> element into <kur_infl>
+ split the three different kinds of info from the old <class> element into:
++ a variable for class (=Roman numeral before comma)
++ a variable for ablaut (=Arabic numeral after comma, if there is one)
++ a variable for special [I don't have a better label] (=Asterisk, if there is one)
+ add a variable kur_ID="xxx" (xxx to be specified later when the <LINK TYPE="OT"> is merged, see next task)

two examples
<e kur_ID="207">
      <lg>
         <l pos="n">а̄ррьп</l>
         <infl>
         	<kur_stem kur_ID="xxx" case="nom" number="pl">а̄рьп</kur_stem>
         	<kur_infl class="II" ablaut="1">
         </infl>
      </lg>
      
<e kur_ID="440">
      <lg>
         <l pos="v">ве̄ҏтэдтэ</l>
         <infl>
         	<kur_infl class="I" ablaut="1" special="*">
         </infl>
      </lg>
==> DONE <==
